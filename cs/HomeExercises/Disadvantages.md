## Недостатки подхода №2

  + #### Читаемость
	Приходится читать много строк кода, пока смотришь реализацию метода AreEqual(...).\
	Факт правильности нужно еще подтвердить, внимательно читая код 
	(иначе пришлось бы писать тесты на тесты, а программисты ленивые)\
	Во FluentAssertions (далее FA) весь тест укладывается в 1-2 строки, читается при этом отлично.
	Более того, эта библиотека популярна и ей можно доверять, так что документации (и даже описанию методов) можно верить.
  
  + #### Расширяемость
	Добавление нового поля (которое нужно учитывать при сравнении) в класс Person приведет к нескольким неприятным последствиям:
      	
	* если для поля реализован метод Equals:\
			необходимо добавить еще одну строку кода со сравненинем через ==;
	* для поля не реализован метод Equals:\
			нужно будет реализовать метод, схожий с данным, для сравнения полей данного типа,\
			иначе тест упадет, т.к. == может вернуть true только на сравнении самого с собой (сравнение по ссылкам);
	В FA добавление нового поля не приведет к изменению теста, кроме случая, когда поле не учитывается (как Id) - тогда нужно добавить одну строку кода (дополнительный options.Excluding)
  + #### Рекурсия
    AreEqual реализован рекурсивно, что ведет к тому, что если у некоторой персоны очень много предков (или какие-то зацикленные),
	получим StackOverflowException.
	FA по дефолту ограничивает глубину сравнения, при этом можно либо вообще отключить рекурсивные сравнения, либо позволить им бесконечными быть. За один option!
  + #### Неудачный тест не говорит ничего
		Expected: True
		But was:  False
	Совсем непонятно что произошло и какие поля отличаются. Придется лезть в стектрейс и копаться там, неудобно.
	FA скажет точно, какое поле отличалось и где.